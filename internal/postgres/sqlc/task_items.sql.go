// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: task_items.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const findTaskItemsByProjectID = `-- name: FindTaskItemsByProjectID :many
SELECT t.id, t.user_id, t.username, t.project_id, t.project_title, t.completed_by, t.completed_by_name, t.description, t.priority, t.state, t.deadline, t.schedule, t.wait, t."create", t."end", t.tags, t.urgency, COUNT(*) OVER()
FROM task_items t
WHERE t.project_id = $1
AND (to_tsvector(
	t.username
	|| ' '
	|| t.completed_by_name
	|| ' ' 
	|| t.description
	|| ' '
	|| array_to_string(tags, ' ')) @@ websearch_to_tsquery($2) OR $2 IS NULL
)
AND (t.state = $3::task_state OR $3 IS NULL)
AND (t.priority = $4::task_priority OR $4 IS NULL)
AND (
	   (t.deadline BETWEEN now() AND (now() + $5::interval))
        OR (t.schedule BETWEEN now() AND (now() + $5::interval))
        OR (t.wait BETWEEN now() AND (now() + $5::interval))
	OR $5 IS NULL
)
ORDER BY urgency DESC
LIMIT $7 OFFSET $6
`

type FindTaskItemsByProjectIDParams struct {
	ProjectID    uuid.NullUUID
	Q            pgtype.Text
	State        NullTaskState
	Priority     NullTaskPriority
	TimeInterval pgtype.Interval
	Noffset      int32
	Nlimit       int32
}

type FindTaskItemsByProjectIDRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Username        string
	ProjectID       uuid.NullUUID
	ProjectTitle    string
	CompletedBy     uuid.NullUUID
	CompletedByName string
	Description     string
	Priority        TaskPriority
	State           TaskState
	Deadline        time.Time
	Schedule        time.Time
	Wait            time.Time
	Create          time.Time
	End             time.Time
	Tags            []string
	Urgency         pgtype.Numeric
	Count           int64
}

func (q *Queries) FindTaskItemsByProjectID(ctx context.Context, arg FindTaskItemsByProjectIDParams) ([]FindTaskItemsByProjectIDRow, error) {
	rows, err := q.db.Query(ctx, findTaskItemsByProjectID,
		arg.ProjectID,
		arg.Q,
		arg.State,
		arg.Priority,
		arg.TimeInterval,
		arg.Noffset,
		arg.Nlimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTaskItemsByProjectIDRow
	for rows.Next() {
		var i FindTaskItemsByProjectIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.ProjectID,
			&i.ProjectTitle,
			&i.CompletedBy,
			&i.CompletedByName,
			&i.Description,
			&i.Priority,
			&i.State,
			&i.Deadline,
			&i.Schedule,
			&i.Wait,
			&i.Create,
			&i.End,
			&i.Tags,
			&i.Urgency,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTaskItemsByUserID = `-- name: FindTaskItemsByUserID :many
SELECT t.id, t.user_id, t.username, t.project_id, t.project_title, t.completed_by, t.completed_by_name, t.description, t.priority, t.state, t.deadline, t.schedule, t.wait, t."create", t."end", t.tags, t.urgency, COUNT(*) OVER()
FROM task_items t
WHERE t.user_id = $1
AND (
	to_tsvector(
		t.project_title
		|| ' '
		|| t.completed_by_name
		|| ' ' 
		|| t.description
		|| ' '
		|| array_to_string(tags, ' ')
	) @@ websearch_to_tsquery($2) OR $2 IS NULL
)
AND (t.state = $3::task_state OR $3 IS NULL)
AND (t.priority = $4::task_priority OR $4 IS NULL)
AND (
	   (t.deadline BETWEEN now() AND (now() + $5::interval))
        OR (t.schedule BETWEEN now() AND (now() + $5::interval))
        OR (t.wait BETWEEN now() AND (now() + $5::interval))
	OR $5 IS NULL
)
ORDER BY urgency DESC
LIMIT $7 OFFSET $6
`

type FindTaskItemsByUserIDParams struct {
	UserID       uuid.UUID
	Q            pgtype.Text
	State        NullTaskState
	Priority     NullTaskPriority
	TimeInterval pgtype.Interval
	Noffset      int32
	Nlimit       int32
}

type FindTaskItemsByUserIDRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	Username        string
	ProjectID       uuid.NullUUID
	ProjectTitle    string
	CompletedBy     uuid.NullUUID
	CompletedByName string
	Description     string
	Priority        TaskPriority
	State           TaskState
	Deadline        time.Time
	Schedule        time.Time
	Wait            time.Time
	Create          time.Time
	End             time.Time
	Tags            []string
	Urgency         pgtype.Numeric
	Count           int64
}

func (q *Queries) FindTaskItemsByUserID(ctx context.Context, arg FindTaskItemsByUserIDParams) ([]FindTaskItemsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, findTaskItemsByUserID,
		arg.UserID,
		arg.Q,
		arg.State,
		arg.Priority,
		arg.TimeInterval,
		arg.Noffset,
		arg.Nlimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTaskItemsByUserIDRow
	for rows.Next() {
		var i FindTaskItemsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.ProjectID,
			&i.ProjectTitle,
			&i.CompletedBy,
			&i.CompletedByName,
			&i.Description,
			&i.Priority,
			&i.State,
			&i.Deadline,
			&i.Schedule,
			&i.Wait,
			&i.Create,
			&i.End,
			&i.Tags,
			&i.Urgency,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const taskItemByID = `-- name: TaskItemByID :one
SELECT id, user_id, username, project_id, project_title, completed_by, completed_by_name, description, priority, state, deadline, schedule, wait, "create", "end", tags, urgency FROM task_items
WHERE user_id=$1
AND id=$2
`

type TaskItemByIDParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) TaskItemByID(ctx context.Context, arg TaskItemByIDParams) (TaskItem, error) {
	row := q.db.QueryRow(ctx, taskItemByID, arg.UserID, arg.ID)
	var i TaskItem
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.ProjectID,
		&i.ProjectTitle,
		&i.CompletedBy,
		&i.CompletedByName,
		&i.Description,
		&i.Priority,
		&i.State,
		&i.Deadline,
		&i.Schedule,
		&i.Wait,
		&i.Create,
		&i.End,
		&i.Tags,
		&i.Urgency,
	)
	return i, err
}
